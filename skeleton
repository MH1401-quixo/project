#create menu
print('1) player vs player')
print('2) player vs computer')
print('3) quit game')

game_play=input("Please select the game mode:")

#error check for menu  
while game_play != '1' and game_play != '2' and game_play != '3' :
    print('Please choose either 1, 2 or 3 only.')
    game_play=input("Please select the game mode:")

choice = input('Do you want to choose your board size? (please choose yes or no): ')

#error check for choice
while choice != 'yes' and choice != 'no': 
    print('invalid choice')
    choice = input('Do you want to choose your board size? (please choose yes or no): ')

import numpy as np

#creating the default board
if choice == 'no':
    s = 5 
    my_mat = np.zeros([s, s])
    print(my_mat)

#board based on player's choice    
elif choice == 'yes':
    s = (int(input('Please enter the size of the board:')))
    #error check
    while s <= 0: 
        print('error')
        s = (int(input('Please enter the size of the board:')))

#print the board of player's choice
else: 
    my_mat = np.zeros([s, s])
    print(my_mat)
        

player = int(input('Do you want to be player 1 or player 2? (please input either 1 or 2): '))


while player != 1 and player !=2:
    print('error')
    player = int(input('Do you want to be player 1 or player 2? (please input either 1 or 2): '))

#we neeed to assign player 1 with chess piece= -1 and player 2 with chess piece = 1 
def win(s):
    """check if the board win
    returns my_mat
    """
    win = 1
    lose = 0 
    draw = 2
    if runproduct == s:
        print('win')
    elif runproduct == -s:
        print('win')
    else: 
        return my_mat

runproduct = 1
while win(s) == 0:
    

r = int(input('Please select a row from the outer boundary:'))
c = int(input('Please select a column from the outer boundary:'))

while (r >= 1) and (r <= s-1)and (c <= s-1) and (c >= 1) or (r < 0) or (c < 0) or (r > s) or (c > s) :
    print('error, please select only the outer boundary blocks')
    r = int(input('Please select a row from the outer boundary:'))
    c = int(input('Please select a column from the outer boundary:'))
    
#player 1, piece is 1 makes a move 
def move1 (r, c, my_mat, s):
    """when a player selects row r and column c, it will change the matrix board into the player1 piece.
    Returns the matrix board
    """
    while my_mat [r, c] == -1 or ((r >= 1) and (r <= s-1)and (c <= s-1) and (c >= 1)) or (r < 0) or (c < 0) or (r > s) or (c > s):
      print('invalid move, you can only choose the row and column that has a blank face or your own symbol on the outer boundary')
      r = int(input('Please select a row from the outer boundary:'))
      c = int(input('Please select a column from the outer boundary:'))
  
    if [r,c]==[0,0]:    #TOP LEFT CORNER
        direction=input('Please push UP or LEFT (case sensitive):')
        while direction != 'UP' and direction != 'LEFT':
            print('Please think clearly and try again')
            direction=input('Please push UP or LEFT (case sensitive):')
        if direction == 'UP': #if player chooses up direction
            my_column = np.linspace(0,0,s) #making the new vector with s entries
            my_column = my_mat[:,0] #assign the entries onto the first column
            my_column1 = np.linspace(0,0,s-1) #making the new vector with s-1 entries
            for x in range(s-1): 
                my_column1[x]=my_column[x+1] #after removing the first piece(from the first row and first column) shift the remaining elements to replace the removed entry position
            my_column2 = np.concatenate([my_column1,np.array([-1])]) #join back the first piece as the last position
            for y in range(s):
                my_mat[y,0]=my_column2[y] #replace the first column of my_mat with my_column2
            return my_mat
        
        else:   #if player choose to move in the left direction 
            my_column = np.linspace(0,0,s) #making the new vector with s entries 
            my_column = my_mat[0,:] #assign the entries onto the first row 
            my_column1 = np.linspace(0,0,s-1) #making the new vector with s-1 entries
            for x in range(s-1): 
                my_column1[x]=my_column[x+1] #after removing the first piece(from the first row and first column) shift the remaining entries to replace the removed entry position
            my_column2 = np.concatenate([my_column1,np.array([-1])]) #join back the first piece as the last position 
            for y in range(s):
                my_mat[0,y]=my_column2[y] #replace the first row of my_mat with my_column2
            return my_mat
        
    elif [r, c] == [0, s-1]: #TOP RIGHT CORNER CASE
        direction=input('Please push UP or RIGHT (case sensitive):')
        while direction != 'UP' and direction != 'RIGHT':
            print('Please think clearly and try again')
            direction=input('Please push UP or RIGHT (case sensitive):')
        if direction == 'UP': #if player chooses up direction
            my_column = np.linspace(0,0,s) #making the new vector with s entries
            my_column = my_mat[:,s-1] #assign the entries onto the last column
            my_column1 = np.linspace(0,0,s-1) #making the new vector with s-1 entries
            for x in range(s-1): 
                my_column1[x]=my_column[x+1] #after removing the first piece(from the first row and last column) shift the remaining elements to replace the removed entry position
            my_column2 = np.concatenate([my_column1,np.array([-1])]) #join back the first piece as the last position
            for y in range(s):
                my_mat[y,s-1]=my_column2[y] #replace the last column of my_mat with my_column2
            return my_mat
        
        else:   #if player choose to move in the right direction 
            my_column = np.linspace(0,0,s) #making the new vector with s entries 
            my_column = my_mat[0,:] #assign the entries onto the first row 
            my_column1 = np.linspace(0,0,s-1) #making the new vector with s-1 entries
            for x in range(s-1): 
                my_column1[x]=my_column[x] #after removing the first piece(from the first row and last column) shift the remaining entries to replace the removed entry position
            my_column2 = np.concatenate([np.array([-1]), my_column1]) #join back the first piece as the last position 
            for y in range(s):
                my_mat[0,y]=my_column2[y] #replace the first row of my_mat with my_column2
            return my_mat
         
    elif [r, c] == [s-1, 0]: #BOTTOM LEFT CORNER CASE
        direction=input('Please push DOWN or LEFT (case sensitive):')
        while direction != 'DOWN' and direction != 'LEFT':
            print('Please think clearly and try again')
            direction=input('Please push DOWN or LEFT (case sensitive):')
        if direction == 'DOWN': #if player chooses down direction
            my_column = np.linspace(0,0,s) #making the new vector with s entries
            my_column = my_mat[:,0] #assign the entries onto the first column
            my_column1 = np.linspace(0,0,s-1) #making the new vector with s-1 entries
            for x in range(s-1): 
                my_column1[x]=my_column[x+1] #after removing the first piece(from the first column and last row) shift the remaining elements to replace the removed entry position
            my_column2 = np.concatenate([np.array([-1]),my_column1]) #join back the first piece as the last position
            for y in range(s):
                my_mat[y,0]=my_column2[y] #replace the first column of my_mat with my_column2
            return my_mat
        
        else:   #if player choose to move in the left direction 
            my_column = np.linspace(0,0,s) #making the new vector with s entries 
            my_column = my_mat[s-1,:] #assign the entries onto the last row 
            my_column1 = np.linspace(0,0,s-1) #making the new vector with s-1 entries
            for x in range(s-1): 
                my_column1[x]=my_column[x+1] #after removing the first piece(from the first column and last row) shift the remaining entries to replace the removed entry position
            my_column2 = np.concatenate([my_column1,np.array([-1])]) #join back the first piece as the last position 
            for y in range(s):
                my_mat[s-1,y]=my_column2[y] #replace the last row of my_mat with my_column2
            return my_mat
    
    elif [r, c] == [s-1, s-1]: #BOTTOM RIGHT CORNER CASE
        direction=input('Please push DOWN or RIGHT (case sensitive):')
        while direction != 'DOWN' and direction != 'RIGHT':
            print('Please think clearly and try again')
            direction=input('Please push DOWN or RIGHT (case sensitive):')
        if direction == 'DOWN': #if player chooses down direction
            my_column = np.linspace(0,0,s) #making the new vector with s entries
            my_column = my_mat[:,s-1] #assign the entries onto the last column
            my_column1 = np.linspace(0,0,s-1) #making the new vector with s-1 entries
            for x in range(s-1): 
                my_column1[x]=my_column[x+1] #after removing the first piece(from the last row and last column) shift the remaining elements to replace the removed entry position
            my_column2 = np.concatenate([np.array([-1]),my_column1]) #join back the first piece as the last position
            for y in range(s):
                my_mat[y,s-1]=my_column2[y] #replace the last column of my_mat with my_column2
            return my_mat
        
        else:   #if player choose to move in the right direction 
            my_column = np.linspace(0,0,s) #making the new vector with s entries 
            my_column = my_mat[s-1,:] #assign the entries onto the last row 
            my_column1 = np.linspace(0,0,s-1) #making the new vector with s-1 entries
            for x in range(s-1): 
                my_column1[x]=my_column[x] #after removing the first piece(from the last row and last column) shift the remaining entries to replace the removed entry position
            my_column2 = np.concatenate([np.array([-1]), my_column1]) #join back the first piece as the last position 
            for y in range(s):
                my_mat[s-1,y]=my_column2[y] #replace the last row of my_mat with my_column2
            return my_mat

#4 edges eg first row is (0,s) then we need to exclude the corner by excluding 0 and s-1 column
            
            
  #TOP EDGE SIDES
     elif r == 0 and c != 0 and c != (s-1):
        direction=input('Please push UP or LEFT or RIGHT (case sensitive):')
        while direction == 'DOWN':                                               #Error check
            print('Please think clearly and try again')
            direction=input('Please push UP or LEFT or RIGHT (case sensitive):') #if the user input correctly, will break the while loop automatically
            
        if direction == 'UP':
            my_column = np.linspace(0,0,s)
            my_column = my_mat[:,c]                                             #equating my_column with c column of the my_mat.   Can also use my_mat[r,:] but in general if push vertically use column more easier, if its push horizontally use row better
            my_column1 = np.linspace(0,0,s-1)
            for x in range(s-1):                                                
                my_column1[x]=my_column[x+1]                                    #Index of my_column1 eg [1] = my_column eg [2], Hence the link is x+1
            my_column2 = np.concatenate([my_column1,np.array([-1])])             #adding np.array([1]) to the end of my_column1
            for y in range(s):                                                  #Running through every s
                my_mat[y,c]=my_column2[y]                                       #replace the y row, c column of the my_mat with my_column2
            return my_mat
        
        elif direction == 'LEFT':
            my_column = np.linspace(0,0,s)
            my_column = my_mat[r,:]                                             #equating my_column with r row of the my_mat. In general if push horizontally use row easier, if push vertically use column easier
            my_column1 = np.linspace(0,0,s-1)
            for x in range(s-1):
                if x < c:                                                       #for x < c your index of my_column1 and my_column will be the same
                    my_column1[x]=my_column[x]
                else:                                                           #else when x > c your index of my_column1 eg=2 will be the index of my_column eg=3, so the pattern for index is x+1
                    my_column1[x]=my_column[x+1]
            my_column2 = np.concatenate([my_column1,np.array([-1])])             #Because you are inserting np.array[1] at the end of my_column1)
            for y in range(s):
                my_mat[r,y]=my_column2[y]                                       #replacing the r row with y column of my_mat with entire my_column2
            return my_mat
        
        
        elif direction == 'RIGHT':
            my_column = np.linspace(0,0,s)
            my_column = my_mat[r,:]
            my_column1 = np.linspace(0,0,s-1)
            for x in range(s-1):
                if x < c:
                    my_column1[x]=my_column[x]
                else:
                    my_column1[x]=my_column[x+1]
            my_column2=np.concatenate([np.array([-1]),my_column1])
            for y in range(s):
                my_mat[r,y]=my_column2[y]
            return my_mat
        
                
  #BOTTOM EDGE SIDES
      elif r == s-1 and c != 0 and c != (s-1):
          direction=input('Please push DOWN or LEFT or RIGHT (case sensitive):')
          while direction == 'UP':
              print('Please think clearly and try again')
              direction=input('Please push DOWN or LEFT or RIGHT (case sensitive):')
              
          if direction == 'DOWN':
             my_column = np.linspace(0,0,s) 
             my_column = my_mat[:,c] 
             my_column1 = np.linspace(0,0,s-1)
             for x in range(s-1):
                my_column1[x]=my_column[x]
             my_column2 = np.concatenate([np.array([-1]),my_column1])
             for y in range(s):
                 my_mat[y,c] = my_column2[y]
             return my_mat
         
          elif direction == 'LEFT':
            my_column = np.linspace(0,0,s)
            my_column = my_mat[r,:]                                             #equating my_column with r row of the my_mat
            my_column1 = np.linspace(0,0,s-1)
            for x in range(s-1):
                if x < c:
                    my_column1[x] = my_column[x]
                else:
                    my_column1[x] = my_column[x+1]
            my_column2 = np.concatenate([my_column1,np.array([-1])])
            for y in range(s):
                my_mat[r,y] = my_column2[y]
            return my_mat    
         
          elif direction == 'RIGHT':
            my_column = np.linspace(0,0,s)
            my_column = my_mat[r,:]
            my_column1 = np.linspace(0,0,s-1)
            for x in range(s-1): 
                if x < c:
                     my_column1[x] = my_column[x]
                else:
                    my_column1[x] = my_column[x+1]
            my_column2 = np.concatenate([np.array([-1]),my_column1])
            for y in range(s): 
                my_mat[r,y] = my_column2[y]
            return my_mat    
          
    #LEFT EDGE SIDE

        elif c == 0 and r != 0 and r != (s-1):
            direction=input('Please push LEFT or UP or DOWN (case sensitive): ')
            while direction == 'RIGHT':
              print('Please think clearly and try again')
              direction=input('Please push LEFT or UP or DOWN (case sensitive):')
            
            if direction == 'LEFT':
                my_column = np.linspace(0,0,s) 
                my_column = my_mat[r,:] 
                my_column1 = np.linspace(0,0,s-1)
                for x in range(s-1):
                    my_column1[x]=my_column[x+1]
                my_column2 = np.concatenate(my_column1,np.array([-1])])
             for y in range(s):
                 my_mat[r,y] = my_column2[y]
             return my_mat
             
         
            if direction == 'UP':
                my_column = np.linspace(0,0,s) 
                my_column = my_mat[:,c] 
                my_column1 = np.linspace(0,0,s-1)
                for x in range(s-1): 
                    if x < r:
                        my_column1[x] = my_column[x]
                    else:
                        my_column1[x] = my_column[x+1]
            my_column2 = np.concatenate(my_column1,np.array([-1])])
            for y in range(s): 
                my_mat[y,c] = my_column2[y]
            return my_mat
        
        
            if direction == 'DOWN':
                my_column = np.linspace(0,0,s) 
                my_column = my_mat[:,c] 
                my_column1 = np.linspace(0,0,s-1)
                for x in range(s-1): 
                    if x < r:
                        my_column1[x] = my_column[x]
                    else:
                        my_column1[x] = my_column[x+1]
            my_column2 = np.concatenate([np.array([-1]),my_column1])
            for y in range(s): 
                my_mat[y,c] = my_column2[y]
            return my_mat
        
#RIGHT EDGE SIDE
        elif c == (s-1) and r != 0 and r != (s-1):
            direction=input('Please push RIGHT or UP or DOWN (case sensitive): ')
            while direction == 'LEFT':
              print('Please think clearly and try again')
              direction=input('Please push RIGHT or UP or DOWN (case sensitive):')
            
            if direction == 'RIGHT':
                my_column = np.linspace(0,0,s) 
                my_column = my_mat[r,:] 
                my_column1 = np.linspace(0,0,s-1)
                for x in range(s-1):
                    my_column1[x]=my_column[x+1]
                my_column2 = np.concatenate([np.array([-1]),my_column1])
             for y in range(s):
                 my_mat[r,y] = my_column2[y]
             return my_mat
             
         
            if direction == 'UP':
                my_column = np.linspace(0,0,s) 
                my_column = my_mat[:,c] 
                my_column1 = np.linspace(0,0,s-1)
                for x in range(s-1): 
                    if x < r:
                        my_column1[x] = my_column[x]
                    else:
                        my_column1[x] = my_column[x+1]
            my_column2 = np.concatenate(my_column1,np.array([-1])])
            for y in range(s): 
                my_mat[y,c] = my_column2[y]
            return my_mat
        
        
            if direction == 'DOWN':
                my_column = np.linspace(0,0,s) 
                my_column = my_mat[:,c] 
                my_column1 = np.linspace(0,0,s-1)
                for x in range(s-1): 
                    if x < r:
                        my_column1[x] = my_column[x]
                    else:
                        my_column1[x] = my_column[x+1]
            my_column2 = np.concatenate([np.array([-1]),my_column1])
            for y in range(s): 
                my_mat[y,c] = my_column2[y]
            return my_mat 
   
  my_mat[r, c] == -1??????
  return my_mat?????
  
  
  
  
  #NOW NEED DO PLAYER 2
  #player 2, piece is 1 makes a move 
def move1 (r, c, my_mat, s):
    """when a player selects row r and column c, it will change the matrix board into the player1 piece.
    Returns the matrix board
    """
    while my_mat [r, c] == -1 or ((r >= 1) and (r <= s-1)and (c <= s-1) and (c >= 1)) or (r < 0) or (c < 0) or (r > s) or (c > s):
      print('invalid move, you can only choose the row and column that has a blank face or your own symbol on the outer boundary')
      r = int(input('Please select a row from the outer boundary:'))
      c = int(input('Please select a column from the outer boundary:'))????????????
  
    if [r,c]==[0,0]:    #TOP LEFT CORNER
        direction=input('Please push UP or LEFT (case sensitive):')
        while direction != 'UP' and direction != 'LEFT':
            print('Please think clearly and try again')
            direction=input('Please push UP or LEFT (case sensitive):')
        if direction == 'UP': #if player chooses up direction
            my_column = np.linspace(0,0,s) #making the new vector with s entries
            my_column = my_mat[:,0] #assign the entries onto the first column
            my_column1 = np.linspace(0,0,s-1) #making the new vector with s-1 entries
            for x in range(s-1): 
                my_column1[x]=my_column[x+1] #after removing the first piece(from the first row and first column) shift the remaining elements to replace the removed entry position
            my_column2 = np.concatenate([my_column1,np.array([1])]) #join back the first piece as the last position
            for y in range(s):
                my_mat[y,0]=my_column2[y] #replace the first column of my_mat with my_column2
            return my_mat
        
        else:   #if player choose to move in the left direction 
            my_column = np.linspace(0,0,s) #making the new vector with s entries 
            my_column = my_mat[0,:] #assign the entries onto the first row 
            my_column1 = np.linspace(0,0,s-1) #making the new vector with s-1 entries
            for x in range(s-1): 
                my_column1[x]=my_column[x+1] #after removing the first piece(from the first row and first column) shift the remaining entries to replace the removed entry position
            my_column2 = np.concatenate([my_column1,np.array([1])]) #join back the first piece as the last position 
            for y in range(s):
                my_mat[0,y]=my_column2[y] #replace the first row of my_mat with my_column2
            return my_mat
        
    elif [r, c] == [0, s-1]: #TOP RIGHT CORNER CASE
        direction=input('Please push UP or RIGHT (case sensitive):')
        while direction != 'UP' and direction != 'RIGHT':
            print('Please think clearly and try again')
            direction=input('Please push UP or RIGHT (case sensitive):')
        if direction == 'UP': #if player chooses up direction
            my_column = np.linspace(0,0,s) #making the new vector with s entries
            my_column = my_mat[:,s-1] #assign the entries onto the last column
            my_column1 = np.linspace(0,0,s-1) #making the new vector with s-1 entries
            for x in range(s-1): 
                my_column1[x]=my_column[x+1] #after removing the first piece(from the first row and last column) shift the remaining elements to replace the removed entry position
            my_column2 = np.concatenate([my_column1,np.array([1])]) #join back the first piece as the last position
            for y in range(s):
                my_mat[y,s-1]=my_column2[y] #replace the last column of my_mat with my_column2
            return my_mat
        
        else:   #if player choose to move in the right direction 
            my_column = np.linspace(0,0,s) #making the new vector with s entries 
            my_column = my_mat[0,:] #assign the entries onto the first row 
            my_column1 = np.linspace(0,0,s-1) #making the new vector with s-1 entries
            for x in range(s-1): 
                my_column1[x]=my_column[x] #after removing the first piece(from the first row and last column) shift the remaining entries to replace the removed entry position
            my_column2 = np.concatenate([np.array([1]), my_column1]) #join back the first piece as the last position 
            for y in range(s):
                my_mat[0,y]=my_column2[y] #replace the first row of my_mat with my_column2
            return my_mat
         
    elif [r, c] == [s-1, 0]: #BOTTOM LEFT CORNER CASE
        direction=input('Please push DOWN or LEFT (case sensitive):')
        while direction != 'DOWN' and direction != 'LEFT':
            print('Please think clearly and try again')
            direction=input('Please push DOWN or LEFT (case sensitive):')
        if direction == 'DOWN': #if player chooses down direction
            my_column = np.linspace(0,0,s) #making the new vector with s entries
            my_column = my_mat[:,0] #assign the entries onto the first column
            my_column1 = np.linspace(0,0,s-1) #making the new vector with s-1 entries
            for x in range(s-1): 
                my_column1[x]=my_column[x+1] #after removing the first piece(from the first column and last row) shift the remaining elements to replace the removed entry position
            my_column2 = np.concatenate([np.array([1]),my_column1]) #join back the first piece as the last position
            for y in range(s):
                my_mat[y,0]=my_column2[y] #replace the first column of my_mat with my_column2
            return my_mat
        
        else:   #if player choose to move in the left direction 
            my_column = np.linspace(0,0,s) #making the new vector with s entries 
            my_column = my_mat[s-1,:] #assign the entries onto the last row 
            my_column1 = np.linspace(0,0,s-1) #making the new vector with s-1 entries
            for x in range(s-1): 
                my_column1[x]=my_column[x+1] #after removing the first piece(from the first column and last row) shift the remaining entries to replace the removed entry position
            my_column2 = np.concatenate([my_column1,np.array([1])]) #join back the first piece as the last position 
            for y in range(s):
                my_mat[s-1,y]=my_column2[y] #replace the last row of my_mat with my_column2
            return my_mat
    
    elif [r, c] == [s-1, s-1]: #BOTTOM RIGHT CORNER CASE
        direction=input('Please push DOWN or RIGHT (case sensitive):')
        while direction != 'DOWN' and direction != 'RIGHT':
            print('Please think clearly and try again')
            direction=input('Please push DOWN or RIGHT (case sensitive):')
        if direction == 'DOWN': #if player chooses down direction
            my_column = np.linspace(0,0,s) #making the new vector with s entries
            my_column = my_mat[:,s-1] #assign the entries onto the last column
            my_column1 = np.linspace(0,0,s-1) #making the new vector with s-1 entries
            for x in range(s-1): 
                my_column1[x]=my_column[x+1] #after removing the first piece(from the last row and last column) shift the remaining elements to replace the removed entry position
            my_column2 = np.concatenate([np.array([1]),my_column1]) #join back the first piece as the last position
            for y in range(s):
                my_mat[y,s-1]=my_column2[y] #replace the last column of my_mat with my_column2
            return my_mat
        
        else:   #if player choose to move in the right direction 
            my_column = np.linspace(0,0,s) #making the new vector with s entries 
            my_column = my_mat[s-1,:] #assign the entries onto the last row 
            my_column1 = np.linspace(0,0,s-1) #making the new vector with s-1 entries
            for x in range(s-1): 
                my_column1[x]=my_column[x] #after removing the first piece(from the last row and last column) shift the remaining entries to replace the removed entry position
            my_column2 = np.concatenate([np.array([1]), my_column1]) #join back the first piece as the last position 
            for y in range(s):
                my_mat[s-1,y]=my_column2[y] #replace the last row of my_mat with my_column2
            return my_mat

#4 edges eg first row is (0,s) then we need to exclude the corner by excluding 0 and s-1 column
            
            
  #TOP EDGE SIDES
     elif r == 0 and c != 0 and c != (s-1):
        direction=input('Please push UP or LEFT or RIGHT (case sensitive):')
        while direction == 'DOWN':                                               #Error check
            print('Please think clearly and try again')
            direction=input('Please push UP or LEFT or RIGHT (case sensitive):') #if the user input correctly, will break the while loop automatically
            
        if direction == 'UP':
            my_column = np.linspace(0,0,s)
            my_column = my_mat[:,c]                                             #equating my_column with c column of the my_mat.   Can also use my_mat[r,:] but in general if push vertically use column more easier, if its push horizontally use row better
            my_column1 = np.linspace(0,0,s-1)
            for x in range(s-1):                                                
                my_column1[x]=my_column[x+1]                                    #Index of my_column1 eg [1] = my_column eg [2], Hence the link is x+1
            my_column2 = np.concatenate([my_column1,np.array([1])])             #adding np.array([1]) to the end of my_column1
            for y in range(s):                                                  #Running through every s
                my_mat[y,c]=my_column2[y]                                       #replace the y row, c column of the my_mat with my_column2
            return my_mat
        
        elif direction == 'LEFT':
            my_column = np.linspace(0,0,s)
            my_column = my_mat[r,:]                                             #equating my_column with r row of the my_mat. In general if push horizontally use row easier, if push vertically use column easier
            my_column1 = np.linspace(0,0,s-1)
            for x in range(s-1):
                if x < c:                                                       #for x < c your index of my_column1 and my_column will be the same
                    my_column1[x]=my_column[x]
                else:                                                           #else when x > c your index of my_column1 eg=2 will be the index of my_column eg=3, so the pattern for index is x+1
                    my_column1[x]=my_column[x+1]
            my_column2 = np.concatenate([my_column1,np.array([1])])             #Because you are inserting np.array[1] at the end of my_column1)
            for y in range(s):
                my_mat[r,y]=my_column2[y]                                       #replacing the r row with y column of my_mat with entire my_column2
            return my_mat
        
        
        elif direction == 'RIGHT':
            my_column = np.linspace(0,0,s)
            my_column = my_mat[r,:]
            my_column1 = np.linspace(0,0,s-1)
            for x in range(s-1):
                if x < c:
                    my_column1[x]=my_column[x]
                else:
                    my_column1[x]=my_column[x+1]
            my_column2=np.concatenate([np.array([1]),my_column1])
            for y in range(s):
                my_mat[r,y]=my_column2[y]
            return my_mat
        
                
  #BOTTOM EDGE SIDES
      elif r == s-1 and c != 0 and c != (s-1):
          direction=input('Please push DOWN or LEFT or RIGHT (case sensitive):')
          while direction == 'UP':
              print('Please think clearly and try again')
              direction=input('Please push DOWN or LEFT or RIGHT (case sensitive):')
              
          if direction == 'DOWN':
             my_column = np.linspace(0,0,s) 
             my_column = my_mat[:,c] 
             my_column1 = np.linspace(0,0,s-1)
             for x in range(s-1):
                my_column1[x]=my_column[x]
             my_column2 = np.concatenate([np.array([1]),my_column1])
             for y in range(s):
                 my_mat[y,c] = my_column2[y]
             return my_mat
         
          elif direction == 'LEFT':
            my_column = np.linspace(0,0,s)
            my_column = my_mat[r,:]                                             #equating my_column with r row of the my_mat
            my_column1 = np.linspace(0,0,s-1)
            for x in range(s-1):
                if x < c:
                    my_column1[x] = my_column[x]
                else:
                    my_column1[x] = my_column[x+1]
            my_column2 = np.concatenate([my_column1,np.array([1])])
            for y in range(s):
                my_mat[r,y] = my_column2[y]
            return my_mat    
         
          elif direction == 'RIGHT':
            my_column = np.linspace(0,0,s)
            my_column = my_mat[r,:]
            my_column1 = np.linspace(0,0,s-1)
            for x in range(s-1): 
                if x < c:
                     my_column1[x] = my_column[x]
                else:
                    my_column1[x] = my_column[x+1]
            my_column2 = np.concatenate([np.array([1]),my_column1])
            for y in range(s): 
                my_mat[r,y] = my_column2[y]
            return my_mat    
          
    #LEFT EDGE SIDE

        elif c == 0 and r != 0 and r != (s-1):
            direction=input('Please push LEFT or UP or DOWN (case sensitive): ')
            while direction == 'RIGHT':
              print('Please think clearly and try again')
              direction=input('Please push LEFT or UP or DOWN (case sensitive):')
            
            if direction == 'LEFT':
                my_column = np.linspace(0,0,s) 
                my_column = my_mat[r,:] 
                my_column1 = np.linspace(0,0,s-1)
                for x in range(s-1):
                    my_column1[x]=my_column[x+1]
                my_column2 = np.concatenate(my_column1,np.array([1])])
             for y in range(s):
                 my_mat[r,y] = my_column2[y]
             return my_mat
             
         
            if direction == 'UP':
                my_column = np.linspace(0,0,s) 
                my_column = my_mat[:,c] 
                my_column1 = np.linspace(0,0,s-1)
                for x in range(s-1): 
                    if x < r:
                        my_column1[x] = my_column[x]
                    else:
                        my_column1[x] = my_column[x+1]
            my_column2 = np.concatenate(my_column1,np.array([1])])
            for y in range(s): 
                my_mat[y,c] = my_column2[y]
            return my_mat
        
        
            if direction == 'DOWN':
                my_column = np.linspace(0,0,s) 
                my_column = my_mat[:,c] 
                my_column1 = np.linspace(0,0,s-1)
                for x in range(s-1): 
                    if x < r:
                        my_column1[x] = my_column[x]
                    else:
                        my_column1[x] = my_column[x+1]
            my_column2 = np.concatenate([np.array([1]),my_column1])
            for y in range(s): 
                my_mat[y,c] = my_column2[y]
            return my_mat
        
#RIGHT EDGE SIDE
        elif c == (s-1) and r != 0 and r != (s-1):
            direction=input('Please push RIGHT or UP or DOWN (case sensitive): ')
            while direction == 'LEFT':
              print('Please think clearly and try again')
              direction=input('Please push RIGHT or UP or DOWN (case sensitive):')
            
            if direction == 'RIGHT':
                my_column = np.linspace(0,0,s) 
                my_column = my_mat[r,:] 
                my_column1 = np.linspace(0,0,s-1)
                for x in range(s-1):
                    my_column1[x]=my_column[x+1]
                my_column2 = np.concatenate([np.array([1]),my_column1])
             for y in range(s):
                 my_mat[r,y] = my_column2[y]
             return my_mat
             
         
            if direction == 'UP':
                my_column = np.linspace(0,0,s) 
                my_column = my_mat[:,c] 
                my_column1 = np.linspace(0,0,s-1)
                for x in range(s-1): 
                    if x < r:
                        my_column1[x] = my_column[x]
                    else:
                        my_column1[x] = my_column[x+1]
            my_column2 = np.concatenate(my_column1,np.array([1])])
            for y in range(s): 
                my_mat[y,c] = my_column2[y]
            return my_mat
        
        
            if direction == 'DOWN':
                my_column = np.linspace(0,0,s) 
                my_column = my_mat[:,c] 
                my_column1 = np.linspace(0,0,s-1)
                for x in range(s-1): 
                    if x < r:
                        my_column1[x] = my_column[x]
                    else:
                        my_column1[x] = my_column[x+1]
            my_column2 = np.concatenate([np.array([1]),my_column1])
            for y in range(s): 
                my_mat[y,c] = my_column2[y]
            return my_mat 
  

#player 1 makes a move first
#error check whether the move is valid (mmust be a r and c that represent a blank face or his symbol) and the direction
#if its not valid, print invalid move
    #else print the move board
    #then check whether victory is achieved
    
#if there is victory, break
    #print you have won yay fml
    
#player 2 makes a move first
def move2 (r,c):
    """when a player selects row r and column c, it will change the matrix board into the player2 piece.
    Returns the matrix board
    """
    if my_mat [r, c] != 0:
        print('invalid move, you can only choose the row and column that has a blank face or your own symbol')
    my_mat[r, c] == 1
    return my_mat
#error check whether the move is valid
#if its not valid, print invalid move
    #else print the move
    #then check whether victory is achieved
    
#if there is victory, break
    #print you have won yay fml
    
#RANDOM COMPUTER  (all the 5 should be changed to variable s)
import random
# If computer moves first
def generaterandommove():
    r=random.randint(0,5-1)
    if r==0 or r==5-1:
        c=random.randint(0,5-1)
    else:
        c=random.choice([0,5-1])
    return (r,c)

# If player moves first
# If player chooses [r,c]=[0,0] and direction==UP
def ranmove1_00():
    r=random.randint(0,5-1)
    if r==0:
        c=random.randint(0,5-1)
    elif r==4:
        c=random.randint(1,5-1)
    else:
        c=random.choice([0,5-1])
    return (r,c)

# If player chooses [r,c]=[0,0] and direction==LEFT
def ranmove2_00():
    r=random.randint(0,5-1)
    if r==0:
        c=random.randint(0,5-2)
    elif r==4:
        c=random.randint(0,5-1)
    else:
        c=random.choice([0,5-1])
    return (r,c) 


# If player chooses [r,c]=[0,s-1] and direction==UP
def ranmove1_0s():
    r=random.randint(0,5-1)
    if r==0:
        c=random.randint(0,5-1)
    elif r==4:
        c=random.randint(0,5-2)
    else:
        c=random.choice([0,5-1])
    return (r,c)     

# If player chooses [r,c]=[0,s-1] and direction==RIGHT
def ranmove2_0s():
    r=random.randint(0,5-1)
    if r==0:
        c=random.randint(1,5-1)
    elif r==4:
        c=random.randint(0,5-1)
    else:
        c=random.choice([0,5-1])
    return (r,c) 


# If player chooses [r,c]=[s-1,0] and direction==DOWN
def ranmove1_s0():
    r=random.randint(0,5-1)
    if r==0:
        c=random.randint(1,5-1)
    elif r==4:
        c=random.randint(0,5-1)
    else:
        c=random.choice([0,5-1])
    return (r,c)

# If player chooses [r,c]=[s-1,0] and direction==LEFT
def ranmove2_s0():
    r=random.randint(0,5-1)
    if r==0:
        c=random.randint(0,5-1)
    elif r==4:
        c=random.randint(0,5-2)
    else:
        c=random.choice([0,5-1])
    return (r,c) 


# If player chooses [r,c]=[s-1,s-1] and direction==DOWN
def ranmove1_ss():
    r=random.randint(0,5-1)
    if r==0:
        c=random.randint(0,5-2)
    elif r==4:
        c=random.randint(0,5-1)
    else:
        c=random.choice([0,5-1])
    return (r,c) 

# If player chooses [r,c]=[s-1,s-1] and direction==RIGHT
def ranmove2_ss():
    r=random.randint(0,5-1)
    if r==0:
        c=random.randint(0,5-1)
    elif r==4:
        c=random.randint(1,5-1)
    else:
        c=random.choice([0,5-1])
    return (r,c)    
    
 # if player moves top side and direction==UP
def ranmovetop1():
    r=random.randint(0,5-1)
    if r==5-1:          # Computer moves may vary depending on the input c that player chose
        c=random.choice([0,5-1])
    elif r==0:
        c=random.randint(0,5-1)
    else:
        c=random.choice([0,5-1])
    return (r,c) 

# if player moves top side and direction==LEFT
def ranmovetop2():
    r=random.randint(0,5-1)
    if r==5-1:
        c=random.randint(0,5-1)
    elif r==0:         # Computer moves may vary depending on the input c that player chose
        c=random.randint(0,5-2)
    else:
        c=random.choice([0,5-1])
    return(r,c)    

# if player moves top side and direction==RIGHT
def ranmovetop3():
    r=random.randint(0,5-1)
    if r==5-1:
        c=random.randint(0,5-1)
    elif r==0:         # Computer moves may vary depending on the input c that player chose
        c=random.randint(1,5-1)
    else:
        c=random.choice([0,5-1])
    return(r,c)  

  
# if player moves bottom side and direction==DOWN
def ranmovebottom1():
    r=random.randint(0,5-1)
    if r==5-1:
        c=random.randint(0,5-1)
    elif r==0:         # Computer moves may vary depending on the input c that player chose
        c=random.choice([0,5-1])
    else:
        c=random.choice([0,5-1])
    return(r,c)      

# if player moves bottom side and direction==LEFT
def ranmovebottom2():
    r=random.randint(0,5-1)
    if r==5-1:        # Computer moves may vary depending on the input c that player chose
        c=random.randint(0,5-2)
    elif r==0:         
        c=random.randint(0,5-2)
    else:
        c=random.choice([0,5-1])
    return(r,c)    

# if player moves bottom side and direction==RIGHT
def ranmovebottom3():
    r=random.randint(0,5-1)
    if r==5-1:        # Computer moves may vary depending on the input c that player chose
        c=random.randint(1,5-1)
    elif r==0:         
        c=random.randint(0,5-2)
    else:
        c=random.choice([0,5-1])
    return(r,c)    
    

  


#how to win is when sum of rows or columns or diagonal entries = 5 or -5
#special case if one player makes the final move and result in sum both 5 and -5 at the same time
#Then the person who makes the final move loses
#print the player who win
