#create menu
print('1) player vs player')
print('2) player vs computer')
print('3) quit game')

game_play=input("Please select the game mode:")

#error check for menu  
while game_play != '1' and game_play != '2' and game_play != '3' :
    print('Please choose either 1, 2 or 3 only.')
    game_play=input("Please select the game mode:")

choice = input('Do you want to choose your board size? (please choose yes or no): ')

#error check for choice
while choice != 'yes' and choice != 'no': 
    print('invalid choice')
    choice = input('Do you want to choose your board size? (please choose yes or no): ')

import numpy as np

#creating the default board
if choice == 'no':
    s = 5 
    my_mat = np.zeros([s, s])
    print(my_mat)

#board based on player's choice    
elif choice == 'yes':
    s = (int(input('Please enter the size of the board:')))
    #error check
    while s <= 0: 
        print('error')
        s = (int(input('Please enter the size of the board:')))

#print the board of player's choice
else: 
    my_mat = np.zeros([s, s])
    print(my_mat)
        

player = int(input('Do you want to be player 1 or player 2? (please input either 1 or 2): '))


while player != 1 and player !=2:
    print('error')
    player = int(input('Do you want to be player 1 or player 2? (please input either 1 or 2): '))

#we neeed to assign player 1 with chess piece= -1 and player 2 with chess piece = 1 
def win(s):
    """check if the board win
    returns my_mat
    """
    win = 1
    lose = 0 
    draw = 2
    if runproduct == s:
        print('win')
    elif runproduct == -s:
        print('win')
    else: 
        return my_mat

runproduct = 1
while win(s) == 0:
    

r = int(input('Please select a row from the outer boundary:'))
c = int(input('Please select a column from the outer boundary:'))

while (r >= 1) and (r <= s-1)and (c <= s-1) and (c >= 1) or (r < 0) or (c < 0) or (r > s) or (c > s) :
    print('error, please select only the outer boundary blocks')
    r = int(input('Please select a row from the outer boundary:'))
    c = int(input('Please select a column from the outer boundary:'))
    
#player 1, piece is 1 makes a move 
def move1 (r, c, my_mat, s):
    """when a player selects row r and column c, it will change the matrix board into the player1 piece.
    Returns the matrix board
    """
    while my_mat [r, c] == -1 or ((r >= 1) and (r <= s-1)and (c <= s-1) and (c >= 1)) or (r < 0) or (c < 0) or (r > s) or (c > s)
      print('invalid move, you can only choose the row and column that has a blank face or your own symbol on the outer boundary')
      r = int(input('Please select a row from the outer boundary:'))
      c = int(input('Please select a column from the outer boundary:'))
  
    if [r,c]==[0,0]:    #first corner case
        direction=input('Please push UP or LEFT (case sensitive):')
        while direction != 'UP' and direction != 'LEFT':
            print('Please think clearly and try again')
            direction=input('Please push UP or LEFT (case sensitive):')
        if direction == 'UP': #if player chooses up direction
            my_column = np.linspace(0,0,s) #making the new vector with s entries
            my_column = my_mat[:,0] #assign the entries onto the first column
            my_column1 = np.linspace(0,0,s-1) #making the new vector with s-1 entries
            for x in range(s-1): 
                my_column1[x]=my_column[x+1] #after removing the first piece shift the remaining elements to replace the removed entry position
            my_column2 = np.concatenate([my_column1,np.array([1])]) #join back the first piece as the last position
            for y in range(s):
                my_mat[y,0]=my_column2[y] #replace the first column of my_mat with my_column2
            return my_mat
        
        else direction == 'LEFT':   #if player choose to move in the left direction 
            my_column = np.linspace(0,0,s) #making the new vector with s entries 
            my_column = my_mat[0,:] #assign the entries onto the first row 
            my_column1 = np.linspace(0,0,s-1) #making the new vector with s-1 entries
            for x in range(s-1): 
                my_column1[x]=my_column[x+1] #after removing the first piece shift the remaining entries to replace the removed entry position
            my_column2 = np.concatenate([my_column1,np.array([1])]) #join back the first piece as the last position 
            for y in range(s):
                my_mat[0,y]=my_column2[y] #replace the first row of my_mat with my_column2
            return my_mat
        
     elif  [r, c] == [0, s-1]:
         direction=input('Please push UP or RIGHT (case sensitive):')
        while direction != 'UP' and direction != 'RIGHT':
            print('Please think clearly and try again')
            direction=input('Please push UP or RIGHT (case sensitive):')
        if direction == 'UP': #if player chooses up direction
            my_column = np.linspace(0,0,s) #making the new vector with s entries
            my_column = my_mat[:,s-1] #assign the entries onto the last column
            my_column1 = np.linspace(0,0,s-1) #making the new vector with s-1 entries
            for x in range(s-1): 
                my_column1[x]=my_column[x+1] #after removing the first piece shift the remaining elements to replace the removed entry position
            my_column2 = np.concatenate([my_column1,np.array([1])]) #join back the first piece as the last position
            for y in range(s):
                my_mat[y,s-1]=my_column2[y] #replace the first column of my_mat with my_column2
            return my_mat
        
        else direction == 'RIGHT':   #if player choose to move in the right direction 
            my_column = np.linspace(0,0,s) #making the new vector with s entries 
            my_column = my_mat[0,:] #assign the entries onto the first row 
            my_column1 = np.linspace(0,0,s-1) #making the new vector with s-1 entries
            for x in range(s-1): 
                my_column1[x]=my_column[x] #after removing the first piece shift the remaining entries to replace the removed entry position
            my_column2 = np.concatenate([np.array([1]), my_column1]) #join back the first piece as the last position 
            for y in range(s):
                my_mat[0,y]=my_column2[y] #replace the first row of my_mat with my_column2
            return my_mat
         
        
#8 cases = 4 corner cases + 4 sides in terms of r and s

#4 edges eg first row is (0,s) then we need to exclude the corner by excluding 0 and s-1 column
            
            
  #HK & FARIS do until here FOR top side
     elif r == 0 and c != 0 and c != (s-1):
        direction=input('Please push UP or LEFT or RIGHT (case sensitive):')
        while direction == 'DOWN':                                               #Error check
            print('Please think clearly and try again')
            direction=input('Please push UP or LEFT or RIGHT (case sensitive):') #if the user input correctly, will break the while loop automatically
            
        if direction == 'UP':
            my_column = np.linspace(0,0,s)
            my_column = my_mat[:,c]                                             #equating my_column with c column of the my_mat.   Can also use my_mat[r,:] but in general if push vertically use column more easier, if its push horizontally use row better
            my_column1 = np.linspace(0,0,s-1)
            for x in range(s-1):                                                
                my_column1[x]=my_column[x+1]                                    #Index of my_column1 eg [1] = my_column eg [2], Hence the link is x+1
            my_column2 = np.concatenate([my_column1,np.array([1])])             #adding np.array([1]) to the end of my_column1
            for y in range(s):                                                  #Running through every s
                my_mat[y,c]=my_column2[y]                                       #replace the y row, c column of the my_mat with my_column2
            return my_mat
        
        elif direction == 'LEFT':
            my_column = np.linspace(0,0,s)
            my_column = my_mat[r,:]                                             #equating my_column with r row of the my_mat. In general if push horizontally use row easier, if push vertically use column easier
            my_column1 = np.linspace(0,0,s-1)
            for x in range(s-1):
                if x < c:                                                       #for x < c your index of my_column1 and my_column will be the same
                    my_column1[x]=my_column[x]
                else:                                                           #else when x > c your index of my_column1 eg=2 will be the index of my_column eg=3, so the pattern for index is x+1
                    my_column1[x]=my_column[x+1]
            my_column2 = np.concatenate([my_column1,np.array([1])])             #Because you are inserting np.array[1] at the end of my_column1)
            for y in range(s):
                my_mat[r,y]=my_column2[y]                                       #replacing the r row with y column of my_mat with entire my_column2
            return my_mat
        
        
        elif direction == 'RIGHT':
            my_column = np.linspace(0,0,s)
            my_column = my_mat[r,:]
            my_column1 = np.linspace(0,0,s-1)
            for x in range(s-1):
                if x < c:
                    my_column1[x]=my_column[x]
                else:
                    my_column1[x]=my_column[x+1]
            my_column2=np.concatenate([np.array([1]),my_column1])
            for y in range(s):
                my_mat[r,y]=my_column2[y]
            return my_mat
        
                
        #FOR bottom side
      elif r == s-1 and c != 0 and c != (s-1):
          direction=input('Please push DOWN or LEFT or RIGHT (case sensitive):')
          while direction == 'UP':
              print('Please think clearly and try again')
              direction=input('Please push DOWN or LEFT or RIGHT (case sensitive):')
              
          if direction == 'DOWN':
             my_column = np.linspace(0,0,s) 
             my_column = my_mat[:,c] 
             my_column1 = np.linspace(0,0,s-1)
             for x in range(s-1):
                my_column1[x]=my_column[x]
             my_column2 = np.concatenate([np.array([1]),my_column1])
             for y in range(s):
                 my_mat[y,c] = my_column2[y]
             return my_mat
         
          elif direction == 'LEFT':
            my_column = np.linspace(0,0,s)
            my_column = my_mat[r,:]                                             #equating my_column with r row of the my_mat
            my_column1 = np.linspace(0,0,s-1)
            for x in range(s-1):
                if x < c:
                    my_column1[x] = my_column[x]
                else:
                    my_column1[x] = my_column[x+1]
            my_column2 = np.concatenate([my_column1,np.array([1])])
            for y in range(s):
                my_mat[r,y] = my_column2[y]
            return my_mat    
         
          elif direction == 'RIGHT':
            my_column = np.linspace(0,0,s)
            my_column = my_mat[r,:]
            my_column1 = np.linspace(0,0,s-1)
            for x in range(s-1): 
                if x < c:
                     my_column1[x] = my_column[x]
                else:
                    my_column1[x] = my_column[x+1]
            my_column2 = np.concatenate([np.array([1]),my_column1])
            for y in range(s): 
                my_mat[r,y] = my_column2[y]
            return my_mat    
          
      
  my_mat[r, c] == -1
  return my_mat
    

#player 1 makes a move first
#error check whether the move is valid (mmust be a r and c that represent a blank face or his symbol) and the direction
#if its not valid, print invalid move
    #else print the move board
    #then check whether victory is achieved
    
#if there is victory, break
    #print you have won yay fml
    
#player 2 makes a move first
def move2 (r,c):
    """when a player selects row r and column c, it will change the matrix board into the player2 piece.
    Returns the matrix board
    """
    if my_mat [r, c] != 0:
        print('invalid move, you can only choose the row and column that has a blank face or your own symbol')
    my_mat[r, c] == 1
    return my_mat
#error check whether the move is valid
#if its not valid, print invalid move
    #else print the move
    #then check whether victory is achieved
    
#if there is victory, break
    #print you have won yay fml


#how to win is when sum of rows or columns or diagonal entries = 5 or -5
#special case if one player makes the final move and result in sum both 5 and -5 at the same time
#Then the person who makes the final move loses
#print the player who win
